// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: receiver.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// auth may be done with some standard things like OAuth2, so no connect here,
/// WebSocket is considered to be authenticated already
struct ProtoReceiver {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  struct Subscribe {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var senderID: ProtoIdentifier {
      get {return _senderID ?? ProtoIdentifier()}
      set {_senderID = newValue}
    }
    /// Returns true if `senderID` has been explicitly set.
    var hasSenderID: Bool {return self._senderID != nil}
    /// Clears the value of `senderID`. Subsequent reads from it will return its default value.
    mutating func clearSenderID() {self._senderID = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _senderID: ProtoIdentifier? = nil
  }

  struct Unsubscribe {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var senderID: ProtoIdentifier {
      get {return _senderID ?? ProtoIdentifier()}
      set {_senderID = newValue}
    }
    /// Returns true if `senderID` has been explicitly set.
    var hasSenderID: Bool {return self._senderID != nil}
    /// Clears the value of `senderID`. Subsequent reads from it will return its default value.
    mutating func clearSenderID() {self._senderID = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _senderID: ProtoIdentifier? = nil
  }

  struct Scopes {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var unknownFields = SwiftProtobuf.UnknownStorage()

    struct Response {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      var scopes: [ProtoReceiver.Scopes.Response.Scope] = []

      var unknownFields = SwiftProtobuf.UnknownStorage()

      struct Scope {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        var id: ProtoIdentifier {
          get {return _id ?? ProtoIdentifier()}
          set {_id = newValue}
        }
        /// Returns true if `id` has been explicitly set.
        var hasID: Bool {return self._id != nil}
        /// Clears the value of `id`. Subsequent reads from it will return its default value.
        mutating func clearID() {self._id = nil}

        var name: String = String()

        var parent: ProtoIdentifier {
          get {return _parent ?? ProtoIdentifier()}
          set {_parent = newValue}
        }
        /// Returns true if `parent` has been explicitly set.
        var hasParent: Bool {return self._parent != nil}
        /// Clears the value of `parent`. Subsequent reads from it will return its default value.
        mutating func clearParent() {self._parent = nil}

        var unknownFields = SwiftProtobuf.UnknownStorage()

        init() {}

        fileprivate var _id: ProtoIdentifier? = nil
        fileprivate var _parent: ProtoIdentifier? = nil
      }

      init() {}
    }

    init() {}
  }

  struct Logs {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var logs: [ProtoLog] = []

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct Error {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var code: String = String()

    var message: String = String()

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct NetworkMessage {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var id: ProtoIdentifier {
      get {return _id ?? ProtoIdentifier()}
      set {_id = newValue}
    }
    /// Returns true if `id` has been explicitly set.
    var hasID: Bool {return self._id != nil}
    /// Clears the value of `id`. Subsequent reads from it will return its default value.
    mutating func clearID() {self._id = nil}

    var content: ProtoReceiver.NetworkMessage.OneOf_Content? = nil

    var error: ProtoReceiver.Error {
      get {
        if case .error(let v)? = content {return v}
        return ProtoReceiver.Error()
      }
      set {content = .error(newValue)}
    }

    var logs: ProtoReceiver.Logs {
      get {
        if case .logs(let v)? = content {return v}
        return ProtoReceiver.Logs()
      }
      set {content = .logs(newValue)}
    }

    var scopesRequest: ProtoReceiver.Scopes {
      get {
        if case .scopesRequest(let v)? = content {return v}
        return ProtoReceiver.Scopes()
      }
      set {content = .scopesRequest(newValue)}
    }

    var scopesResponse: ProtoReceiver.Scopes.Response {
      get {
        if case .scopesResponse(let v)? = content {return v}
        return ProtoReceiver.Scopes.Response()
      }
      set {content = .scopesResponse(newValue)}
    }

    var subscribe: ProtoReceiver.Subscribe {
      get {
        if case .subscribe(let v)? = content {return v}
        return ProtoReceiver.Subscribe()
      }
      set {content = .subscribe(newValue)}
    }

    var unsubscribe: ProtoReceiver.Unsubscribe {
      get {
        if case .unsubscribe(let v)? = content {return v}
        return ProtoReceiver.Unsubscribe()
      }
      set {content = .unsubscribe(newValue)}
    }

    var unknownFields = SwiftProtobuf.UnknownStorage()

    enum OneOf_Content: Equatable {
      case error(ProtoReceiver.Error)
      case logs(ProtoReceiver.Logs)
      case scopesRequest(ProtoReceiver.Scopes)
      case scopesResponse(ProtoReceiver.Scopes.Response)
      case subscribe(ProtoReceiver.Subscribe)
      case unsubscribe(ProtoReceiver.Unsubscribe)

    #if !swift(>=4.1)
      static func ==(lhs: ProtoReceiver.NetworkMessage.OneOf_Content, rhs: ProtoReceiver.NetworkMessage.OneOf_Content) -> Bool {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch (lhs, rhs) {
        case (.error, .error): return {
          guard case .error(let l) = lhs, case .error(let r) = rhs else { preconditionFailure() }
          return l == r
        }()
        case (.logs, .logs): return {
          guard case .logs(let l) = lhs, case .logs(let r) = rhs else { preconditionFailure() }
          return l == r
        }()
        case (.scopesRequest, .scopesRequest): return {
          guard case .scopesRequest(let l) = lhs, case .scopesRequest(let r) = rhs else { preconditionFailure() }
          return l == r
        }()
        case (.scopesResponse, .scopesResponse): return {
          guard case .scopesResponse(let l) = lhs, case .scopesResponse(let r) = rhs else { preconditionFailure() }
          return l == r
        }()
        case (.subscribe, .subscribe): return {
          guard case .subscribe(let l) = lhs, case .subscribe(let r) = rhs else { preconditionFailure() }
          return l == r
        }()
        case (.unsubscribe, .unsubscribe): return {
          guard case .unsubscribe(let l) = lhs, case .unsubscribe(let r) = rhs else { preconditionFailure() }
          return l == r
        }()
        default: return false
        }
      }
    #endif
    }

    init() {}

    fileprivate var _id: ProtoIdentifier? = nil
  }

  init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

extension ProtoReceiver: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "Receiver"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: ProtoReceiver, rhs: ProtoReceiver) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ProtoReceiver.Subscribe: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = ProtoReceiver.protoMessageName + ".Subscribe"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "senderId"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._senderID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._senderID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: ProtoReceiver.Subscribe, rhs: ProtoReceiver.Subscribe) -> Bool {
    if lhs._senderID != rhs._senderID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ProtoReceiver.Unsubscribe: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = ProtoReceiver.protoMessageName + ".Unsubscribe"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "senderId"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._senderID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._senderID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: ProtoReceiver.Unsubscribe, rhs: ProtoReceiver.Unsubscribe) -> Bool {
    if lhs._senderID != rhs._senderID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ProtoReceiver.Scopes: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = ProtoReceiver.protoMessageName + ".Scopes"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: ProtoReceiver.Scopes, rhs: ProtoReceiver.Scopes) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ProtoReceiver.Scopes.Response: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = ProtoReceiver.Scopes.protoMessageName + ".Response"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "scopes"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.scopes) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.scopes.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.scopes, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: ProtoReceiver.Scopes.Response, rhs: ProtoReceiver.Scopes.Response) -> Bool {
    if lhs.scopes != rhs.scopes {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ProtoReceiver.Scopes.Response.Scope: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = ProtoReceiver.Scopes.Response.protoMessageName + ".Scope"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "name"),
    3: .same(proto: "parent"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._id) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._parent) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._id {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 2)
    }
    if let v = self._parent {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: ProtoReceiver.Scopes.Response.Scope, rhs: ProtoReceiver.Scopes.Response.Scope) -> Bool {
    if lhs._id != rhs._id {return false}
    if lhs.name != rhs.name {return false}
    if lhs._parent != rhs._parent {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ProtoReceiver.Logs: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = ProtoReceiver.protoMessageName + ".Logs"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "logs"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.logs) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.logs.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.logs, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: ProtoReceiver.Logs, rhs: ProtoReceiver.Logs) -> Bool {
    if lhs.logs != rhs.logs {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ProtoReceiver.Error: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = ProtoReceiver.protoMessageName + ".Error"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
    2: .same(proto: "message"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.code) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.message) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.code.isEmpty {
      try visitor.visitSingularStringField(value: self.code, fieldNumber: 1)
    }
    if !self.message.isEmpty {
      try visitor.visitSingularStringField(value: self.message, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: ProtoReceiver.Error, rhs: ProtoReceiver.Error) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.message != rhs.message {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ProtoReceiver.NetworkMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = ProtoReceiver.protoMessageName + ".NetworkMessage"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "error"),
    3: .same(proto: "logs"),
    4: .same(proto: "scopesRequest"),
    5: .same(proto: "scopesResponse"),
    6: .same(proto: "subscribe"),
    7: .same(proto: "unsubscribe"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._id) }()
      case 2: try {
        var v: ProtoReceiver.Error?
        if let current = self.content {
          try decoder.handleConflictingOneOf()
          if case .error(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.content = .error(v)}
      }()
      case 3: try {
        var v: ProtoReceiver.Logs?
        if let current = self.content {
          try decoder.handleConflictingOneOf()
          if case .logs(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.content = .logs(v)}
      }()
      case 4: try {
        var v: ProtoReceiver.Scopes?
        if let current = self.content {
          try decoder.handleConflictingOneOf()
          if case .scopesRequest(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.content = .scopesRequest(v)}
      }()
      case 5: try {
        var v: ProtoReceiver.Scopes.Response?
        if let current = self.content {
          try decoder.handleConflictingOneOf()
          if case .scopesResponse(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.content = .scopesResponse(v)}
      }()
      case 6: try {
        var v: ProtoReceiver.Subscribe?
        if let current = self.content {
          try decoder.handleConflictingOneOf()
          if case .subscribe(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.content = .subscribe(v)}
      }()
      case 7: try {
        var v: ProtoReceiver.Unsubscribe?
        if let current = self.content {
          try decoder.handleConflictingOneOf()
          if case .unsubscribe(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.content = .unsubscribe(v)}
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._id {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every case branch when no optimizations are
    // enabled. https://github.com/apple/swift-protobuf/issues/1034
    switch self.content {
    case .error?: try {
      guard case .error(let v)? = self.content else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .logs?: try {
      guard case .logs(let v)? = self.content else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .scopesRequest?: try {
      guard case .scopesRequest(let v)? = self.content else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case .scopesResponse?: try {
      guard case .scopesResponse(let v)? = self.content else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }()
    case .subscribe?: try {
      guard case .subscribe(let v)? = self.content else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }()
    case .unsubscribe?: try {
      guard case .unsubscribe(let v)? = self.content else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: ProtoReceiver.NetworkMessage, rhs: ProtoReceiver.NetworkMessage) -> Bool {
    if lhs._id != rhs._id {return false}
    if lhs.content != rhs.content {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
