// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: sender.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

struct ProtoSender {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  struct Connect {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var apiKey: String = String()

    var id: ProtoIdentifier {
      get {return _id ?? ProtoIdentifier()}
      set {_id = newValue}
    }
    /// Returns true if `id` has been explicitly set.
    var hasID: Bool {return self._id != nil}
    /// Clears the value of `id`. Subsequent reads from it will return its default value.
    mutating func clearID() {self._id = nil}

    var information: ProtoSender.Connect.Information {
      get {return _information ?? ProtoSender.Connect.Information()}
      set {_information = newValue}
    }
    /// Returns true if `information` has been explicitly set.
    var hasInformation: Bool {return self._information != nil}
    /// Clears the value of `information`. Subsequent reads from it will return its default value.
    mutating func clearInformation() {self._information = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    struct Information {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      var applicationID: String = String()

      var application: ProtoSender.Connect.Information.NameAndVersion {
        get {return _application ?? ProtoSender.Connect.Information.NameAndVersion()}
        set {_application = newValue}
      }
      /// Returns true if `application` has been explicitly set.
      var hasApplication: Bool {return self._application != nil}
      /// Clears the value of `application`. Subsequent reads from it will return its default value.
      mutating func clearApplication() {self._application = nil}

      var system: ProtoSender.Connect.Information.NameAndVersion {
        get {return _system ?? ProtoSender.Connect.Information.NameAndVersion()}
        set {_system = newValue}
      }
      /// Returns true if `system` has been explicitly set.
      var hasSystem: Bool {return self._system != nil}
      /// Clears the value of `system`. Subsequent reads from it will return its default value.
      mutating func clearSystem() {self._system = nil}

      var device: ProtoSender.Connect.Information.NameAndVersion {
        get {return _device ?? ProtoSender.Connect.Information.NameAndVersion()}
        set {_device = newValue}
      }
      /// Returns true if `device` has been explicitly set.
      var hasDevice: Bool {return self._device != nil}
      /// Clears the value of `device`. Subsequent reads from it will return its default value.
      mutating func clearDevice() {self._device = nil}

      var unknownFields = SwiftProtobuf.UnknownStorage()

      struct NameAndVersion {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        var name: String = String()

        var version: String {
          get {return _version ?? String()}
          set {_version = newValue}
        }
        /// Returns true if `version` has been explicitly set.
        var hasVersion: Bool {return self._version != nil}
        /// Clears the value of `version`. Subsequent reads from it will return its default value.
        mutating func clearVersion() {self._version = nil}

        var unknownFields = SwiftProtobuf.UnknownStorage()

        init() {}

        fileprivate var _version: String? = nil
      }

      init() {}

      fileprivate var _application: ProtoSender.Connect.Information.NameAndVersion? = nil
      fileprivate var _system: ProtoSender.Connect.Information.NameAndVersion? = nil
      fileprivate var _device: ProtoSender.Connect.Information.NameAndVersion? = nil
    }

    struct Response {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      var token: String = String()

      var unknownFields = SwiftProtobuf.UnknownStorage()

      init() {}
    }

    init() {}

    fileprivate var _id: ProtoIdentifier? = nil
    fileprivate var _information: ProtoSender.Connect.Information? = nil
  }

  struct Scope {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var unknownFields = SwiftProtobuf.UnknownStorage()

    struct Push {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      var name: String = String()

      var unknownFields = SwiftProtobuf.UnknownStorage()

      struct Response {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        var id: ProtoIdentifier {
          get {return _id ?? ProtoIdentifier()}
          set {_id = newValue}
        }
        /// Returns true if `id` has been explicitly set.
        var hasID: Bool {return self._id != nil}
        /// Clears the value of `id`. Subsequent reads from it will return its default value.
        mutating func clearID() {self._id = nil}

        var unknownFields = SwiftProtobuf.UnknownStorage()

        init() {}

        fileprivate var _id: ProtoIdentifier? = nil
      }

      init() {}
    }

    struct Pop {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      var id: ProtoIdentifier {
        get {return _id ?? ProtoIdentifier()}
        set {_id = newValue}
      }
      /// Returns true if `id` has been explicitly set.
      var hasID: Bool {return self._id != nil}
      /// Clears the value of `id`. Subsequent reads from it will return its default value.
      mutating func clearID() {self._id = nil}

      var unknownFields = SwiftProtobuf.UnknownStorage()

      init() {}

      fileprivate var _id: ProtoIdentifier? = nil
    }

    init() {}
  }

  struct AddLogs {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var logs: [ProtoLog] = []

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct Error {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var code: String = String()

    var message: String = String()

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct NetworkMessage {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var id: ProtoIdentifier {
      get {return _id ?? ProtoIdentifier()}
      set {_id = newValue}
    }
    /// Returns true if `id` has been explicitly set.
    var hasID: Bool {return self._id != nil}
    /// Clears the value of `id`. Subsequent reads from it will return its default value.
    mutating func clearID() {self._id = nil}

    var content: ProtoSender.NetworkMessage.OneOf_Content? = nil

    var connectRequest: ProtoSender.Connect {
      get {
        if case .connectRequest(let v)? = content {return v}
        return ProtoSender.Connect()
      }
      set {content = .connectRequest(newValue)}
    }

    var connectResponse: ProtoSender.Connect.Response {
      get {
        if case .connectResponse(let v)? = content {return v}
        return ProtoSender.Connect.Response()
      }
      set {content = .connectResponse(newValue)}
    }

    var scopePushRequest: ProtoSender.Scope.Push {
      get {
        if case .scopePushRequest(let v)? = content {return v}
        return ProtoSender.Scope.Push()
      }
      set {content = .scopePushRequest(newValue)}
    }

    var scopePushResponse: ProtoSender.Scope.Push.Response {
      get {
        if case .scopePushResponse(let v)? = content {return v}
        return ProtoSender.Scope.Push.Response()
      }
      set {content = .scopePushResponse(newValue)}
    }

    var scopePop: ProtoSender.Scope.Pop {
      get {
        if case .scopePop(let v)? = content {return v}
        return ProtoSender.Scope.Pop()
      }
      set {content = .scopePop(newValue)}
    }

    var addLogs: ProtoSender.AddLogs {
      get {
        if case .addLogs(let v)? = content {return v}
        return ProtoSender.AddLogs()
      }
      set {content = .addLogs(newValue)}
    }

    var error: ProtoSender.Error {
      get {
        if case .error(let v)? = content {return v}
        return ProtoSender.Error()
      }
      set {content = .error(newValue)}
    }

    var unknownFields = SwiftProtobuf.UnknownStorage()

    enum OneOf_Content: Equatable {
      case connectRequest(ProtoSender.Connect)
      case connectResponse(ProtoSender.Connect.Response)
      case scopePushRequest(ProtoSender.Scope.Push)
      case scopePushResponse(ProtoSender.Scope.Push.Response)
      case scopePop(ProtoSender.Scope.Pop)
      case addLogs(ProtoSender.AddLogs)
      case error(ProtoSender.Error)

    #if !swift(>=4.1)
      static func ==(lhs: ProtoSender.NetworkMessage.OneOf_Content, rhs: ProtoSender.NetworkMessage.OneOf_Content) -> Bool {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch (lhs, rhs) {
        case (.connectRequest, .connectRequest): return {
          guard case .connectRequest(let l) = lhs, case .connectRequest(let r) = rhs else { preconditionFailure() }
          return l == r
        }()
        case (.connectResponse, .connectResponse): return {
          guard case .connectResponse(let l) = lhs, case .connectResponse(let r) = rhs else { preconditionFailure() }
          return l == r
        }()
        case (.scopePushRequest, .scopePushRequest): return {
          guard case .scopePushRequest(let l) = lhs, case .scopePushRequest(let r) = rhs else { preconditionFailure() }
          return l == r
        }()
        case (.scopePushResponse, .scopePushResponse): return {
          guard case .scopePushResponse(let l) = lhs, case .scopePushResponse(let r) = rhs else { preconditionFailure() }
          return l == r
        }()
        case (.scopePop, .scopePop): return {
          guard case .scopePop(let l) = lhs, case .scopePop(let r) = rhs else { preconditionFailure() }
          return l == r
        }()
        case (.addLogs, .addLogs): return {
          guard case .addLogs(let l) = lhs, case .addLogs(let r) = rhs else { preconditionFailure() }
          return l == r
        }()
        case (.error, .error): return {
          guard case .error(let l) = lhs, case .error(let r) = rhs else { preconditionFailure() }
          return l == r
        }()
        default: return false
        }
      }
    #endif
    }

    init() {}

    fileprivate var _id: ProtoIdentifier? = nil
  }

  init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

extension ProtoSender: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "Sender"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: ProtoSender, rhs: ProtoSender) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ProtoSender.Connect: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = ProtoSender.protoMessageName + ".Connect"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "apiKey"),
    2: .same(proto: "id"),
    3: .same(proto: "information"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.apiKey) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._id) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._information) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.apiKey.isEmpty {
      try visitor.visitSingularStringField(value: self.apiKey, fieldNumber: 1)
    }
    if let v = self._id {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if let v = self._information {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: ProtoSender.Connect, rhs: ProtoSender.Connect) -> Bool {
    if lhs.apiKey != rhs.apiKey {return false}
    if lhs._id != rhs._id {return false}
    if lhs._information != rhs._information {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ProtoSender.Connect.Information: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = ProtoSender.Connect.protoMessageName + ".Information"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "applicationId"),
    2: .same(proto: "application"),
    3: .same(proto: "system"),
    4: .same(proto: "device"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.applicationID) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._application) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._system) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._device) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.applicationID.isEmpty {
      try visitor.visitSingularStringField(value: self.applicationID, fieldNumber: 1)
    }
    if let v = self._application {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if let v = self._system {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    if let v = self._device {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: ProtoSender.Connect.Information, rhs: ProtoSender.Connect.Information) -> Bool {
    if lhs.applicationID != rhs.applicationID {return false}
    if lhs._application != rhs._application {return false}
    if lhs._system != rhs._system {return false}
    if lhs._device != rhs._device {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ProtoSender.Connect.Information.NameAndVersion: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = ProtoSender.Connect.Information.protoMessageName + ".NameAndVersion"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .same(proto: "version"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._version) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if let v = self._version {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: ProtoSender.Connect.Information.NameAndVersion, rhs: ProtoSender.Connect.Information.NameAndVersion) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs._version != rhs._version {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ProtoSender.Connect.Response: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = ProtoSender.Connect.protoMessageName + ".Response"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "token"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.token) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.token.isEmpty {
      try visitor.visitSingularStringField(value: self.token, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: ProtoSender.Connect.Response, rhs: ProtoSender.Connect.Response) -> Bool {
    if lhs.token != rhs.token {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ProtoSender.Scope: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = ProtoSender.protoMessageName + ".Scope"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: ProtoSender.Scope, rhs: ProtoSender.Scope) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ProtoSender.Scope.Push: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = ProtoSender.Scope.protoMessageName + ".Push"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: ProtoSender.Scope.Push, rhs: ProtoSender.Scope.Push) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ProtoSender.Scope.Push.Response: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = ProtoSender.Scope.Push.protoMessageName + ".Response"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._id) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._id {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: ProtoSender.Scope.Push.Response, rhs: ProtoSender.Scope.Push.Response) -> Bool {
    if lhs._id != rhs._id {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ProtoSender.Scope.Pop: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = ProtoSender.Scope.protoMessageName + ".Pop"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._id) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._id {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: ProtoSender.Scope.Pop, rhs: ProtoSender.Scope.Pop) -> Bool {
    if lhs._id != rhs._id {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ProtoSender.AddLogs: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = ProtoSender.protoMessageName + ".AddLogs"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "logs"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.logs) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.logs.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.logs, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: ProtoSender.AddLogs, rhs: ProtoSender.AddLogs) -> Bool {
    if lhs.logs != rhs.logs {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ProtoSender.Error: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = ProtoSender.protoMessageName + ".Error"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
    2: .same(proto: "message"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.code) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.message) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.code.isEmpty {
      try visitor.visitSingularStringField(value: self.code, fieldNumber: 1)
    }
    if !self.message.isEmpty {
      try visitor.visitSingularStringField(value: self.message, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: ProtoSender.Error, rhs: ProtoSender.Error) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.message != rhs.message {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ProtoSender.NetworkMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = ProtoSender.protoMessageName + ".NetworkMessage"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "connectRequest"),
    3: .same(proto: "connectResponse"),
    4: .same(proto: "scopePushRequest"),
    5: .same(proto: "scopePushResponse"),
    6: .same(proto: "scopePop"),
    7: .same(proto: "addLogs"),
    8: .same(proto: "error"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._id) }()
      case 2: try {
        var v: ProtoSender.Connect?
        if let current = self.content {
          try decoder.handleConflictingOneOf()
          if case .connectRequest(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.content = .connectRequest(v)}
      }()
      case 3: try {
        var v: ProtoSender.Connect.Response?
        if let current = self.content {
          try decoder.handleConflictingOneOf()
          if case .connectResponse(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.content = .connectResponse(v)}
      }()
      case 4: try {
        var v: ProtoSender.Scope.Push?
        if let current = self.content {
          try decoder.handleConflictingOneOf()
          if case .scopePushRequest(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.content = .scopePushRequest(v)}
      }()
      case 5: try {
        var v: ProtoSender.Scope.Push.Response?
        if let current = self.content {
          try decoder.handleConflictingOneOf()
          if case .scopePushResponse(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.content = .scopePushResponse(v)}
      }()
      case 6: try {
        var v: ProtoSender.Scope.Pop?
        if let current = self.content {
          try decoder.handleConflictingOneOf()
          if case .scopePop(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.content = .scopePop(v)}
      }()
      case 7: try {
        var v: ProtoSender.AddLogs?
        if let current = self.content {
          try decoder.handleConflictingOneOf()
          if case .addLogs(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.content = .addLogs(v)}
      }()
      case 8: try {
        var v: ProtoSender.Error?
        if let current = self.content {
          try decoder.handleConflictingOneOf()
          if case .error(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.content = .error(v)}
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._id {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every case branch when no optimizations are
    // enabled. https://github.com/apple/swift-protobuf/issues/1034
    switch self.content {
    case .connectRequest?: try {
      guard case .connectRequest(let v)? = self.content else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .connectResponse?: try {
      guard case .connectResponse(let v)? = self.content else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .scopePushRequest?: try {
      guard case .scopePushRequest(let v)? = self.content else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case .scopePushResponse?: try {
      guard case .scopePushResponse(let v)? = self.content else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }()
    case .scopePop?: try {
      guard case .scopePop(let v)? = self.content else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }()
    case .addLogs?: try {
      guard case .addLogs(let v)? = self.content else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    }()
    case .error?: try {
      guard case .error(let v)? = self.content else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: ProtoSender.NetworkMessage, rhs: ProtoSender.NetworkMessage) -> Bool {
    if lhs._id != rhs._id {return false}
    if lhs.content != rhs.content {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
